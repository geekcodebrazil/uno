**Arquivo `script.js` Completo:**

```javascript
// ===== Elementos do DOM =====
const playerHandElement = document.getElementById('player-hand');
const opponentHandElement = document.querySelector('.opponent-hand .card--back');
const deckPileElement = document.getElementById('deck-pile');
const discardPileElement = document.getElementById('discard-pile');
const drawCardBtn = document.getElementById('draw-card-btn'); // Bot√£o Comprar Carta (inferior)
const unoBtn = document.getElementById('uno-btn');            // Bot√£o UNO! (inferior)
const restartGameBtnTop = document.getElementById('restart-game-btn'); // Bot√£o Reiniciar (topo - NOVO)
const gameStatusElement = document.getElementById('game-status');
const colorPickerModal = document.getElementById('color-picker-modal');
const colorButtons = document.querySelectorAll('.color-btn');
const currentYearElement = document.getElementById('current-year');
const playerZoneElement = document.querySelector('.player-area');
const opponentZoneElement = document.querySelector('.opponent-area');

// ===== Vari√°veis de Estado do Jogo =====
let deck = [];
let discardPile = [];
let players = [];
let currentPlayerIndex = 0;
let gameDirection = 1;        // 1 para hor√°rio, -1 para anti-hor√°rio
let currentValidColor = null; // Cor atualmente v√°lida para jogar
let currentValidValue = null; // Valor atualmente v√°lido para jogar (n√∫mero ou tipo de a√ß√£o)
let mustDrawCards = 0;        // Quantidade de cartas acumuladas para compra obrigat√≥ria (+2, +4)
let playerMustPlayOrDraw = false; // Indica se o jogador atual TEM que jogar uma carta de compra ou comprar
let wildColorChoiceCallback = null; // Fun√ß√£o a ser chamada ap√≥s escolha da cor
let unoCalled = [false, false];   // Indica se cada jogador (0: humano, 1: bot) J√Å gritou UNO
let canCallUno = [false, false];  // Indica se cada jogador EST√Å em condi√ß√£o de gritar UNO (tem 1 carta)
let botThinking = false;          // Flag para evitar a√ß√µes do jogador enquanto o bot "pensa"
let botNextColorChoice = null;    // Cor pr√©-escolhida pelo bot para Wild/Wild4
let gameOver = false;             // Flag indicando o fim do jogo

// ===== Constantes do Jogo =====
const COLORS = ['red', 'blue', 'green', 'yellow'];
const VALUES = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'skip', 'reverse', 'draw2'];
const SPECIAL_VALUES = ['wild', 'wild4'];
const CARDS_PER_PLAYER = 7;        // N√∫mero de cartas iniciais
const BOT_TURN_DELAY_MS = 1500;    // Tempo (ms) que o bot leva para "pensar"

// ===== Fun√ß√µes do Jogo =====

/**
 * Cria um baralho padr√£o de UNO com IDs √∫nicos para cada carta.
 * @returns {Array<Object>} O array representando o baralho completo.
 */
function createDeck() {
    const newDeck = [];
    let cardIdCounter = 0; // Contador para IDs √∫nicos

    // Cartas Coloridas Num√©ricas e de A√ß√£o
    COLORS.forEach(color => {
        // Uma carta '0' por cor
        newDeck.push({ color, value: '0', id: `card-${cardIdCounter++}` });
        // Duas cartas '1' a '9' por cor
        for (let i = 1; i <= 9; i++) {
            newDeck.push({ color, value: String(i), id: `card-${cardIdCounter++}` });
            newDeck.push({ color, value: String(i), id: `card-${cardIdCounter++}` });
        }
        // Duas cartas de a√ß√£o (Skip, Reverse, Draw2) por cor
        ['skip', 'reverse', 'draw2'].forEach(value => {
            newDeck.push({ color, value, type: 'action', id: `card-${cardIdCounter++}` });
            newDeck.push({ color, value, type: 'action', id: `card-${cardIdCounter++}` });
        });
    });

    // Cartas Especiais (Wild e Wild Draw 4)
    for (let i = 0; i < 4; i++) {
        newDeck.push({ color: 'special', value: 'wild', type: 'wild', id: `card-${cardIdCounter++}` });
        newDeck.push({ color: 'special', value: 'wild4', type: 'wild', id: `card-${cardIdCounter++}` });
    }

    console.log(`Deck criado com ${newDeck.length} cartas.`);
    return newDeck;
}

/**
 * Embaralha um array utilizando o algoritmo Fisher-Yates.
 * @param {Array<any>} array - O array a ser embaralhado.
 */
function shuffleDeck(array) {
    console.log(`Embaralhando ${array.length} cartas.`);
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Troca elementos
    }
}

/**
 * Distribui as cartas iniciais para os jogadores.
 * Trata erros se n√£o houver cartas suficientes.
 */
function dealCards() {
    console.log(`Distribuindo ${CARDS_PER_PLAYER} cartas para ${players.length} jogadores.`);
    for (let i = 0; i < CARDS_PER_PLAYER; i++) {
        for (const player of players) {
            if (gameOver) return; // Interrompe se o jogo j√° acabou por erro anterior
            // Tenta reembaralhar o descarte se o deck acabar DURANTE a distribui√ß√£o
            if (deck.length === 0 && !reshuffleDiscardPile()) {
                setStatusMessage("Erro cr√≠tico: Faltaram cartas para distribuir!", true);
                endGame(null, true); // Considera empate por falta de cartas
                return;
            }
             // Verifica novamente ap√≥s a tentativa de reembaralhar
             if (deck.length === 0) {
                setStatusMessage("Erro cr√≠tico: Deck vazio inesperadamente ap√≥s tentativa de reembaralhar!", true);
                endGame(null, true);
                return;
            }
            // Compra uma carta para o jogador (sem atualizar a UI ainda para otimizar)
            drawCardFromDeck(player.id, 1, false);
        }
        if (gameOver) return; // Verifica novamente se drawCardFromDeck terminou o jogo
    }
    console.log(`Distribui√ß√£o inicial completa. Tamanho do deck: ${deck.length}.`);
    players.forEach(p => console.log(`  Jogador ${p.id} (${p.name}): ${p.hand.length} cartas.`));
}

/**
 * Inicia ou reinicia um novo jogo de UNO.
 * Configura o estado inicial, baralho, jogadores e a primeira carta.
 */
function startGame() {
    console.log("================ INICIANDO NOVO JOGO ================");
    // 1. Resetar Estado Geral
    gameOver = false;
    botThinking = false;
    deck = createDeck();
    shuffleDeck(deck);
    discardPile = [];
    mustDrawCards = 0;
    playerMustPlayOrDraw = false;
    players = [
        { id: 0, hand: [], isBot: false, name: "Voc√™" },
        { id: 1, hand: [], isBot: true, name: "Bot" }
    ];
    currentPlayerIndex = 0; // Humano come√ßa por padr√£o
    gameDirection = 1;      // Sentido hor√°rio
    wildColorChoiceCallback = null;
    unoCalled = [false, false];
    canCallUno = [false, false];
    botNextColorChoice = null;

    // 2. Resetar UI Visual
    if (currentYearElement) currentYearElement.textContent = new Date().getFullYear(); // Atualiza ano no footer
    setStatusMessage("Embaralhando as cartas..."); // Mensagem inicial
    playerZoneElement?.classList.remove('active-turn', 'has-uno'); // Remove classes de estado
    opponentZoneElement?.classList.remove('active-turn', 'has-uno');
    if(playerHandElement) playerHandElement.innerHTML = ''; // Limpa m√£o visual
    if(opponentHandElement) opponentHandElement.setAttribute('data-count', '0'); // Reseta contador bot
    if(discardPileElement) discardPileElement.innerHTML = '<div class="card card--placeholder"><span>Descarte</span></div>'; // Placeholder descarte
    if(colorPickerModal) colorPickerModal.style.display = 'none'; // Esconde modal de cor

    // Remove bot√£o de reiniciar do *status* se existir (ser√° adicionado ao fim do jogo)
    const oldRestartButtonStatus = gameStatusElement?.querySelector('.btn--restart');
    if (oldRestartButtonStatus) {
        const brBefore = oldRestartButtonStatus.previousElementSibling;
        if(brBefore && brBefore.tagName === 'BR') brBefore.remove();
        oldRestartButtonStatus.remove();
    }

    // 3. Distribuir Cartas
    dealCards();
    if (gameOver) return; // Para se houve erro na distribui√ß√£o

    // 4. Virar Primeira Carta do Descarte
    let firstCard = null;
    let firstCardIndex = -1;
    try {
        // Procura a primeira carta que N√ÉO seja Wild ou Wild4
        firstCardIndex = deck.findIndex(card => card && card.type !== 'wild');
    } catch(e) {
        console.error("Erro ao procurar a primeira carta v√°lida no deck:", e);
        setStatusMessage("Erro cr√≠tico ao iniciar a pilha de descarte!", true);
        endGame(null, true); // Fim de jogo por erro
        return;
    }

    // Tratamento para caso raro de s√≥ haver cartas Wild no deck
    if (firstCardIndex === -1) {
        console.warn("Deck inicial cont√©m apenas cartas Wild/Wild4 ou ocorreu um erro. Usando a √∫ltima carta como fallback.");
        // Se encontrar o erro foi real e n√£o s√≥ Wilds, o deck pode estar vazio
        if(deck.length === 0){
             console.error("ERRO IRRECUPER√ÅVEL: Deck vazio ap√≥s distribui√ß√£o e falha ao encontrar carta inicial!");
             setStatusMessage("Erro fatal: Imposs√≠vel iniciar o jogo!", true);
             endGame(null, true); return;
        }
        firstCardIndex = deck.length - 1; // Usa a √∫ltima carta do deck
    }

    // Remove a carta escolhida do deck e a adiciona ao descarte
    firstCard = deck.splice(firstCardIndex, 1)[0];
    if (!firstCard) { // Valida√ß√£o extra
        console.error("ERRO CR√çTICO: Falha ao obter a carta inicial do deck!");
        setStatusMessage("Erro fatal ao definir a carta inicial!", true);
        endGame(null, true); return;
    }
    discardPile.push(firstCard);

    // Define a cor e valor v√°lidos iniciais (Coringas s√£o tratados no handleInitialCardEffect)
    currentValidColor = (firstCard.color === 'special') ? null : firstCard.color;
    currentValidValue = firstCard.value;

    console.log(`Setup inicial conclu√≠do. Deck: ${deck.length}, Descarte: ${discardPile.length} (Topo: ${firstCard.id}). Cor v√°lida inicial: ${currentValidColor}, Valor v√°lido inicial: ${currentValidValue}`);

    // 5. Aplicar Efeito da Primeira Carta e Iniciar Turno (com delay para visualiza√ß√£o)
    setTimeout(() => {
        if (gameOver) return; // Verifica novamente antes de continuar

        console.log("Aplicando efeito da primeira carta:", firstCard.id, "Jogador atual ANTES:", currentPlayerIndex);
        handleInitialCardEffect(firstCard); // Pode alterar currentPlayerIndex e estado
        console.log("Jogador atual AP√ìS efeito inicial:", currentPlayerIndex);

        // Valida se o jogador atual ainda √© v√°lido
        if (!players[currentPlayerIndex]) {
             console.error(`Erro: Jogador √≠ndice ${currentPlayerIndex} inv√°lido ap√≥s efeito inicial.`);
             setStatusMessage("Erro ao determinar o primeiro jogador!", true);
             endGame(null, true);
             return;
         }

        // Atualiza status para indicar o primeiro jogador
        setStatusMessage(`√â a vez de ${players[currentPlayerIndex].name}!`);

        // Define o indicador visual de turno
        playerZoneElement?.classList.remove('active-turn');
        opponentZoneElement?.classList.remove('active-turn');
        if (currentPlayerIndex === 0) {
            playerZoneElement?.classList.add('active-turn');
        } else {
            opponentZoneElement?.classList.add('active-turn');
        }

        updateUI(); // Atualiza toda a interface
        console.log("Primeira atualiza√ß√£o da UI p√≥s-setup.");

        // Inicia o turno do primeiro jogador (se for o bot, chama a IA)
        if (!gameOver && players[currentPlayerIndex]?.isBot) {
            console.log("O Bot inicia o jogo.");
            botThinking = true;
            triggerBotTurn();
        } else if (!gameOver) {
            console.log("O Humano inicia o jogo.");
            botThinking = false;
            // updateUI() j√° foi chamado, jogador pode interagir.
        }
    }, 600); // Pequeno delay para o jogador ver a carta inicial e o efeito
}

/**
 * Lida com os efeitos especiais da PRIMEIRA carta virada (Skip, Reverse, Draw2).
 * Coringas s√£o tratados separadamente ao serem jogados normalmente.
 * @param {Object} card - A primeira carta virada na pilha de descarte.
 */
function handleInitialCardEffect(card) {
    console.log("Avaliando efeito da primeira carta:", card?.id);
    // Ignora se carta for inv√°lida, nula, ou Wild/Wild4 (Wilds normais n√£o tem efeito inicial especial)
    if (!card || card.type === 'wild') {
        mustDrawCards = 0; playerMustPlayOrDraw = false; return;
    }
    // Efeito s√≥ se aplica a cartas de a√ß√£o coloridas
    if (card.type !== 'action' || card.color === 'special') {
        mustDrawCards = 0; playerMustPlayOrDraw = false; return;
    }

    const initialPlayerIndex = currentPlayerIndex; // Quem come√ßaria normalmente
     if (!players || players.length === 0 || !players[initialPlayerIndex]) {
        console.error("Erro: Jogador inicial inv√°lido no handleInitialCardEffect."); return;
    }
    const initialPlayerName = players[initialPlayerIndex].name;
    let effectApplied = false; // Flag para log

    switch (card.value) {
        case 'skip':
            // Pula o primeiro jogador
            currentPlayerIndex = (initialPlayerIndex + gameDirection + players.length) % players.length;
            setStatusMessage(`Carta inicial: Pular! ${initialPlayerName} perde a primeira vez.`);
            console.log(`Efeito inicial: Skip! ${initialPlayerName} (idx ${initialPlayerIndex}) perde a vez. Pr√≥ximo: ${currentPlayerIndex}.`);
            effectApplied = true;
            break;
        case 'reverse':
             // Com 2 jogadores, funciona como Skip. Com mais, reverteria a ordem (aqui s√≥ 2p)
            currentPlayerIndex = (initialPlayerIndex + gameDirection + players.length) % players.length;
            setStatusMessage(`Carta inicial: Reverter! ${initialPlayerName} perde a primeira vez.`);
            console.log(`Efeito inicial: Reverse! ${initialPlayerName} (idx ${initialPlayerIndex}) perde a vez (2 jogadores). Pr√≥ximo: ${currentPlayerIndex}.`);
            effectApplied = true;
            // Se tivesse mais jogadores: gameDirection *= -1; currentPlayerIndex = ... ;
            break;
        case 'draw2':
             // O jogador que come√ßaria deve comprar 2 cartas e perder a vez
             console.log(`Efeito inicial: +2! ${initialPlayerName} (idx ${initialPlayerIndex}) deve comprar 2.`);
             // Verifica se h√° cartas suficientes para comprar
             if (deck.length < 2 && discardPile.length <= 1) { // Precisa de pelo menos 2 no deck OU 1 no descarte (fora a atual) para reembaralhar
                console.error("Erro cr√≠tico: N√£o h√° cartas suficientes para o +2 inicial!");
                setStatusMessage("Erro: Cartas insuficientes para o +2 inicial!", true);
                endGame(null, true); return; // Fim por falta de cartas
             }
             drawCardFromDeck(initialPlayerIndex, 2, false); // Compra 2, sem update imediato
             if (gameOver) return; // drawCard pode ter finalizado (erro raro aqui)

             currentPlayerIndex = (initialPlayerIndex + gameDirection + players.length) % players.length; // Passa a vez para o pr√≥ximo
             setStatusMessage(`Carta inicial: +2! ${initialPlayerName} compra 2 cartas e perde a vez.`);
             effectApplied = true;
             break;
        // case 'wild': // Wild normal n√£o tem efeito inicial aqui
        // case 'wild4': // Wild +4 NUNCA deve ser a primeira carta virada (segundo regra oficial)
            // break;
    }

    // Resetar flags de compra ap√≥s qualquer efeito inicial
    mustDrawCards = 0;
    playerMustPlayOrDraw = false;

    if (effectApplied) console.log(`Efeito inicial aplicado. O jogador a realmente come√ßar √© o √≠ndice ${currentPlayerIndex}.`);
}


/**
 * Adiciona cartas do baralho para a m√£o de um jogador espec√≠fico.
 * Tenta reembaralhar o descarte se o baralho acabar.
 * Finaliza o jogo como empate se for imposs√≠vel comprar.
 * @param {number} playerId - O ID do jogador (0 ou 1).
 * @param {number} [count=1] - Quantas cartas comprar.
 * @param {boolean} [update=true] - Se deve atualizar a UI ap√≥s comprar.
 * @returns {Array<Object>} As cartas que foram compradas. Retorna array vazio se erro ou imposs√≠vel.
 */
function drawCardFromDeck(playerId, count = 1, update = true) {
    if (gameOver) return [];
    const player = players.find(p => p.id === playerId);
    if (!player) { console.error(`drawCardFromDeck: Jogador ${playerId} n√£o encontrado.`); return []; }

    let drawnCards = [];
    console.log(`Jogador ${playerId} tentando comprar ${count} carta(s). Deck: ${deck.length}, Descarte: ${discardPile.length}.`);

    for (let i = 0; i < count; i++) {
        // Se o deck est√° vazio, tenta reembaralhar
        if (deck.length === 0) {
            console.log("Deck vazio. Tentando reembaralhar pilha de descarte.");
            if (!reshuffleDiscardPile()) {
                // Se n√£o foi poss√≠vel reembaralhar (e o deck continua vazio)
                console.warn(`Imposs√≠vel comprar mais cartas. Jogador ${playerId} comprou ${drawnCards.length} de ${count} solicitadas.`);
                // Condi√ß√£o de empate: Ningu√©m pode comprar mais e ningu√©m venceu
                if (deck.length === 0 && discardPile.length <= 1 && drawnCards.length < count) {
                    setStatusMessage("Fim de jogo: N√£o h√° mais cartas para comprar!", true);
                    console.log("Condi√ß√£o de empate alcan√ßada: Imposs√≠vel comprar mais cartas.")
                    endGame(null, true); // Empate
                }
                return drawnCards; // Retorna o que conseguiu comprar
            }
            // Se reembaralhou com sucesso, o deck agora tem cartas (ou deveria)
             if (deck.length === 0) { // Verifica√ß√£o de seguran√ßa p√≥s-reembaralhamento
                 console.error("ERRO CR√çTICO: Deck continua vazio mesmo ap√≥s tentativa de reembaralhar!");
                 setStatusMessage("Erro fatal no baralho!", true);
                 endGame(null, true); return drawnCards;
             }
        }

        // Compra a carta do topo do deck
        const card = deck.pop();
        if (card) {
            player.hand.push(card);
            drawnCards.push(card);
        } else {
            // Isso n√£o deveria acontecer se as checagens acima funcionam
            console.error("ERRO INESPERADO: deck.pop() retornou undefined mesmo com deck.length > 0!");
            // Tenta continuar se poss√≠vel, mas loga o erro grave.
            break; // Interrompe o loop de compra atual
        }
    }

    console.log(`Jogador ${playerId} comprou ${drawnCards.length} carta(s). Tamanho da m√£o: ${player.hand.length}. Deck restante: ${deck.length}.`);

    // L√≥gica UNO: Se jogador comprou e tinha possibilidade de UNO, ele a perde
    if (player.hand.length > 1 && canCallUno[playerId]) {
        console.log(`Jogador ${playerId} comprou carta(s) e perdeu a condi√ß√£o de UNO.`);
        canCallUno[playerId] = false;
        unoCalled[playerId] = false; // Garante que o 'grito' seja resetado tamb√©m
        // Atualiza UI do bot√£o UNO para o jogador humano
        if (playerId === 0 && unoBtn) {
            unoBtn.disabled = true;
            unoBtn.classList.remove('can-press');
            playerZoneElement?.classList.remove('has-uno'); // Remove badge visual
        }
         if (playerId === 1) {
            opponentZoneElement?.classList.remove('has-uno'); // Remove badge visual bot
         }
    }

    // Atualiza a interface se necess√°rio e o jogo n√£o acabou
    if (update && !gameOver) {
        updateUI();
    }

    return drawnCards;
}

/**
 * Move as cartas da pilha de descarte (exceto a do topo) de volta para o baralho e o embaralha.
 * @returns {boolean} True se o reembaralhamento foi bem-sucedido, False caso contr√°rio.
 */
function reshuffleDiscardPile() {
    console.log(`Tentando reembaralhar ${discardPile.length} cartas do descarte.`);
    // Precisa de pelo menos 2 cartas no descarte para reembaralhar (1 fica no topo)
    if (discardPile.length <= 1) {
        console.warn("N√£o √© poss√≠vel reembaralhar: menos de 2 cartas no descarte.");
        if (deckPileElement) deckPileElement.style.display = 'none'; // Esconde visualmente o deck vazio
        return false;
    }

    // Guarda a carta do topo
    const topCard = discardPile.pop();
    console.log("Mantendo a carta do topo no descarte:", topCard?.id);

    // Move o restante do descarte para o deck
    deck = [...discardPile];
    // Limpa o descarte, deixando apenas a carta do topo
    discardPile = topCard ? [topCard] : [];

    // Embaralha o novo deck
    shuffleDeck(deck);

    console.log(`Reembaralhamento conclu√≠do. Novo Deck: ${deck.length} cartas. Descarte: ${discardPile.length} carta(s).`);

    // Garante que o monte de compra visual apare√ßa se agora temos cartas
    if (deck.length > 0 && deckPileElement) {
        renderDeckPile(); // Re-renderiza o deck pile para mostrar a carta virada
    }
    setStatusMessage("O baralho foi reembaralhado.");
    return true;
}

/**
 * Verifica se uma carta espec√≠fica pode ser jogada sobre a carta atual do topo do descarte.
 * Leva em conta cor, valor, cartas especiais e estado de compra obrigat√≥ria (+2/+4).
 * @param {Object} cardToPlay - A carta que o jogador tenta jogar.
 * @returns {boolean} True se a carta √© jog√°vel, False caso contr√°rio.
 */
function isCardPlayable(cardToPlay) {
    if (gameOver || !cardToPlay) return false; // Jogo acabou ou carta inv√°lida

    const topDiscardCard = discardPile[discardPile.length - 1];
     if (!topDiscardCard) { console.error("isCardPlayable: Descarte vazio inesperadamente!"); return false;} // Descarte nunca deveria estar vazio aqui

    // Regra 1: Se h√° compra acumulada (mustDrawCards > 0)
    if (mustDrawCards > 0) {
        // S√≥ pode jogar Wild+4 OU um Draw+2 da mesma cor (se o topo for Draw+2) ou valor? N√£o, valor ou Wild4 apenas.
        // Oficialmente: S√≥ pode jogar um +2 se a carta do topo for +2 (acumula), ou jogar um +4.
         if (cardToPlay.value === 'wild4') return true; // Wild+4 pode ser jogado sobre +2 ou +4 acumulados
         // Se a √∫ltima carta foi +2, pode jogar outro +2 (qualquer cor)
         if (currentValidValue === 'draw2' && cardToPlay.value === 'draw2') return true;
        // Caso contr√°rio, n√£o pode jogar mais nada, tem que comprar
        return false;
    }

    // Regra 2: Se N√ÉO h√° compra acumulada
    // Carta Wild (Coringa normal) sempre pode ser jogada
    if (cardToPlay.value === 'wild') return true;
    // Carta Wild+4 pode ser jogada (mesmo sem compra acumulada), MAS aten√ß√£o √† regra opcional de ter outra jog√°vel. Neste c√≥digo, permitimos sempre.
    if (cardToPlay.value === 'wild4') return true;

    // Regra 3: Cartas normais/a√ß√£o coloridas
    // Jog√°vel se a COR ou o VALOR/TIPO batem com a carta do topo do descarte
    // Ou se a cor bate com a cor escolhida por um Wild anterior (currentValidColor)
    return cardToPlay.color === currentValidColor || cardToPlay.value === currentValidValue;
}

/**
 * Processa a jogada de uma carta por um jogador.
 * Remove a carta da m√£o, adiciona ao descarte, verifica UNO e condi√ß√£o de vit√≥ria,
 * e ent√£o aplica o efeito da carta jogada.
 * @param {number} playerId - ID do jogador que est√° jogando.
 * @param {number} cardIndex - √çndice da carta na m√£o do jogador.
 */
function playCard(playerId, cardIndex) {
    // Valida√ß√µes Iniciais
    if (gameOver) { console.log("playCard cancelado: Jogo finalizado."); return; }
    if (playerId !== currentPlayerIndex) { console.warn(`playCard bloqueado: N√£o √© a vez do jogador ${playerId}. Vez de: ${currentPlayerIndex}.`); return; }
    if (playerId === 0 && botThinking) { console.log("playCard bloqueado: Aguardando o Bot."); setStatusMessage("Aguarde a vez do Bot!", true); return; } // Evita clique duplo humano

    const player = players[playerId];
    // Valida jogador e √≠ndice da carta
    if (!player || cardIndex < 0 || cardIndex >= player.hand.length || !player.hand[cardIndex]) {
        console.error(`Jogada inv√°lida: Jogador ${playerId}, √çndice ${cardIndex}. M√£o atual:`, player?.hand);
        setStatusMessage("Erro interno: Tentativa de jogar carta inv√°lida.", true);
        return;
    }
    const card = player.hand[cardIndex];

    // Verifica se a carta √© jog√°vel de acordo com as regras
    if (!isCardPlayable(card)) {
        console.log(`Carta ${card.id} (${card.color} ${card.value}) n√£o √© jog√°vel sobre ${currentValidColor} ${currentValidValue}. Compra acumulada: ${mustDrawCards}`);
        setStatusMessage("Esta carta n√£o pode ser jogada agora!", true);
        // Efeito visual de 'shake' na carta inv√°lida (se for humano)
        if (playerId === 0 && playerHandElement) {
            const cardElem = playerHandElement.querySelector(`[data-id="${card.id}"]`);
            if (cardElem) {
                cardElem.style.animation = 'shake 0.5s ease-in-out';
                // Remove a anima√ß√£o ap√≥s terminar para poder aplicar de novo
                setTimeout(() => { cardElem.style.animation = ''; }, 500);
            }
        }
        return; // Interrompe a jogada
    }

    // Se a carta √© jog√°vel:
    // 1. Remove da m√£o do jogador e adiciona ao descarte
    const playedCard = player.hand.splice(cardIndex, 1)[0];
    discardPile.push(playedCard);
    console.log(`Jogador ${playerId} (${player.name}) jogou: ${playedCard.id} (${playedCard.color} ${playedCard.value}). M√£o restante: ${player.hand.length} carta(s).`);

    // 2. Resetar cor/valor v√°lidos (ser√° definido pelo efeito da carta jogada)
    currentValidColor = null; // Ser√° definido pelo efeito, especialmente para Wilds
    currentValidValue = null;

    // 3. Tratar estado UNO
    // Se ficou com 1 carta: Habilita a possibilidade de gritar UNO (ainda n√£o gritou)
    if (player.hand.length === 1) {
        console.log(`Jogador ${playerId} (${player.name}) ficou com 1 carta. Pode gritar UNO!`);
        canCallUno[playerId] = true;  // Agora PODE gritar
        unoCalled[playerId] = false; // Mas AINDA N√ÉO gritou (jogador precisa clicar/bot "decide")
        // Se for o jogador humano, habilita o bot√£o UNO
        if (playerId === 0 && unoBtn) {
            unoBtn.disabled = false;
            unoBtn.classList.add('can-press');
            console.log("Bot√£o UNO habilitado para o jogador.");
            // Opcional: Iniciar um timer curto para penalidade se n√£o clicar
            // startUnoPenaltyTimer(playerId);
        } else if (playerId === 1) { // Bot automaticamente "grita" UNO ao ficar com 1 carta
            console.log("Bot 'gritou' UNO automaticamente.");
            unoCalled[playerId] = true; // Bot j√° gritou
            // Atualiza UI para mostrar badge UNO do Bot
            opponentZoneElement?.classList.add('has-uno');
            setStatusMessage("Bot gritou UNO!");
        }
    }
    // Se jogou e N√ÉO ficou com 1 carta, mas ANTES podia gritar UNO (ex: tinha 2, jogou 1 e esqueceu, agora tem 1), cancela estado UNO pr√©vio
    else if (player.hand.length !== 1 && canCallUno[playerId]) {
         console.log(`Jogador ${playerId} jogou e n√£o est√° mais na condi√ß√£o UNO (M√£o: ${player.hand.length}).`);
         canCallUno[playerId] = false;
         unoCalled[playerId] = false;
         if (playerId === 0 && unoBtn) { // Desabilita bot√£o humano
            unoBtn.disabled = true;
            unoBtn.classList.remove('can-press');
            playerZoneElement?.classList.remove('has-uno'); // Remove badge
         }
         if (playerId === 1) {
             opponentZoneElement?.classList.remove('has-uno'); // Remove badge bot
         }
         // Opcional: cancelar timer de penalidade se existir
         // cancelUnoPenaltyTimer(playerId);
    }
     // Se tinha mais de 1 carta e continua com mais de 1, n√£o faz nada no estado UNO.

    // 4. Atualizar a UI *antes* de aplicar o efeito (para mostrar a carta sendo jogada)
    updateUI();

    // 5. Aplicar o efeito da carta jogada (pode avan√ßar o turno, pedir cor, etc.)
    applyCardEffect(playedCard, playerId); // Importante: A aplica√ß√£o do efeito agora √© respons√°vel por avan√ßar o turno
}

/**
 * Aplica o efeito da carta rec√©m-jogada (Draw2, Skip, Reverse, Wild, Wild4)
 * e, se aplic√°vel, avan√ßa o turno para o pr√≥ximo jogador.
 * @param {Object} card - A carta que foi jogada.
 * @param {number} casterPlayerId - O ID do jogador que jogou a carta.
 */
function applyCardEffect(card, casterPlayerId) {
    if (gameOver || !card) return;

    let advanceTurnNow = true;  // Se o turno deve avan√ßar imediatamente ap√≥s este efeito
    let skipNextPlayer = false; // Se o efeito da carta √© pular o pr√≥ximo jogador
    const caster = players[casterPlayerId];
    // Calcula quem seria o pr√≥ximo jogador ANTES de qualquer mudan√ßa de dire√ß√£o/pulo
    const targetPlayerIndex = (casterPlayerId + gameDirection + players.length) % players.length;
    const targetPlayer = players[targetPlayerIndex];

    console.log(`Aplicando efeito da carta ${card.id} (${card.color} ${card.value}) jogada por ${caster?.name}. Pr√≥ximo seria: ${targetPlayer?.name}`);

    // 1. Atualizar Cor e Valor V√°lidos (Exceto para Wilds que precisam de escolha)
    if (card.type !== 'wild') {
        currentValidColor = card.color;
        currentValidValue = card.value;
        console.log(`Nova cor v√°lida: ${currentValidColor}, Novo valor v√°lido: ${currentValidValue}`);
    } else {
        // Para Wilds, o valor √© definido ('wild' ou 'wild4'), mas a COR depende da escolha do jogador.
        currentValidValue = card.value;
         console.log(`Carta Wild jogada (${card.value}). Valor v√°lido: ${currentValidValue}. Cor ser√° definida.`);
    }

    // 2. Lidar com os Efeitos Espec√≠ficos
    switch (card.value) {
        case 'draw2':
            mustDrawCards += 2; // Acumula +2
            playerMustPlayOrDraw = true; // Pr√≥ximo jogador deve jogar +2/+4 ou comprar
            setStatusMessage(`${caster?.name} jogou +2! ${targetPlayer?.name}, jogue +2/+4 ou compre ${mustDrawCards} cartas.`);
            console.log(`Efeito +2. Compra acumulada: ${mustDrawCards}. Pr√≥ximo jogador (${targetPlayerIndex}) deve jogar ou comprar.`);
            // O turno avan√ßa normalmente para o pr√≥ximo jogador decidir
            break;

        case 'wild4':
            mustDrawCards += 4; // Acumula +4
            playerMustPlayOrDraw = true; // Pr√≥ximo jogador deve jogar +4 ou comprar
            advanceTurnNow = false; // N√ÉO avan√ßa o turno ainda, espera a escolha da cor
            setStatusMessage(`${caster?.name} jogou +4! ${targetPlayer?.name} ter√° que comprar ${mustDrawCards} (a menos que tenha +4). Escolha a nova cor.`);
            console.log(`Efeito +4. Compra acumulada: ${mustDrawCards}. Jogador ${casterPlayerId} escolhe a cor.`);
            // Solicitar escolha de cor (humano ou bot)
            if (caster.isBot) {
                botNextColorChoice = chooseBotColor(); // Bot decide a cor
                // Simula um pequeno delay para escolha de cor do bot tamb√©m
                setTimeout(() => handleColorChoice(botNextColorChoice, casterPlayerId), 300);
            } else {
                promptColorChoice((chosenColor) => handleColorChoice(chosenColor, casterPlayerId)); // Humano escolhe
            }
            return; // Retorna aqui, handleColorChoice avan√ßar√° o turno

        case 'skip':
            // S√≥ pula se n√£o houver compra acumulada
            if (mustDrawCards === 0) {
                skipNextPlayer = true;
                setStatusMessage(`${caster?.name} jogou Pular! ${targetPlayer?.name} perde a vez.`);
                console.log(`Efeito Skip. Pr√≥ximo jogador (${targetPlayerIndex}) ser√° pulado.`);
            } else {
                 console.log("Efeito Skip ignorado devido √† compra acumulada.");
                 // A carta ainda define cor/valor, mas n√£o pula.
            }
            // O turno avan√ßa, mas o advanceTurn pular√° um jogador extra se skipNextPlayer=true
            break;

        case 'reverse':
             // S√≥ reverte/pula se n√£o houver compra acumulada
            if (mustDrawCards === 0) {
                if (players.length === 2) { // Com 2 jogadores, Reverse funciona como Skip
                    skipNextPlayer = true;
                    setStatusMessage(`${caster?.name} jogou Reverter! ${targetPlayer?.name} perde a vez.`);
                    console.log(`Efeito Reverse (2 jogadores). Funciona como Skip. Pr√≥ximo jogador (${targetPlayerIndex}) ser√° pulado.`);
                } else { // Com 3+ jogadores, inverte a dire√ß√£o
                    gameDirection *= -1;
                    setStatusMessage(`${caster?.name} jogou Reverter! A ordem do jogo foi invertida.`);
                    console.log(`Efeito Reverse. Nova dire√ß√£o: ${gameDirection === 1 ? 'Hor√°rio' : 'Anti-hor√°rio'}.`);
                    // O turno avan√ßa na nova dire√ß√£o
                }
            } else {
                 console.log("Efeito Reverse ignorado devido √† compra acumulada.");
                  // A carta ainda define cor/valor, mas n√£o reverte/pula.
            }
            // O turno avan√ßa, considerando a nova dire√ß√£o ou o pulo (se skipNextPlayer=true)
            break;

        case 'wild':
            // S√≥ pede cor se n√£o houver compra acumulada
            if (mustDrawCards === 0) {
                advanceTurnNow = false; // N√ÉO avan√ßa o turno ainda, espera a escolha da cor
                setStatusMessage(`${caster?.name} jogou Coringa! Escolha a nova cor.`);
                console.log(`Efeito Wild. Jogador ${casterPlayerId} escolhe a cor.`);
                 // Solicitar escolha de cor (humano ou bot)
                 if (caster.isBot) {
                     botNextColorChoice = chooseBotColor(); // Bot decide
                      setTimeout(() => handleColorChoice(botNextColorChoice, casterPlayerId), 300);
                 } else {
                     promptColorChoice((chosenColor) => handleColorChoice(chosenColor, casterPlayerId)); // Humano escolhe
                 }
                 return; // Retorna aqui, handleColorChoice avan√ßar√° o turno
            } else {
                console.log("Efeito Wild ignorado (escolha de cor) devido √† compra acumulada.");
                // Wild ainda conta como valor 'wild', mas cor n√£o pode ser escolhida. Mant√©m a cor anterior? N√£o, vira 'special'.
                // A carta foi jogada, mas n√£o permite escolha de cor. O jogo continua com o + acumulado.
                 currentValidColor = 'special'; // A cor anterior n√£o importa mais, pr√≥ximo deve jogar 'wild' ou comprar
                currentValidColor = 'special'; // A cor anterior n√£o importa mais, pr√≥ximo deve jogar 'wild' ou comprar
            currentValidValue = 'wild';
                 // Turno avan√ßa normalmente.
            }
            break;

        default:
            // Cartas num√©ricas n√£o t√™m efeito especial al√©m de definir cor/valor
            console.log(`Carta num√©rica ${card.value} jogada. Sem efeito especial.`);
            // O turno avan√ßa normalmente
            break;
    }

    // 3. Checar Vit√≥ria e Avan√ßar Turno (se n√£o interrompido por escolha de cor)
    if (advanceTurnNow) {
        // Primeiro, verifica se QUEM JOGOU venceu
        if (checkWinCondition(casterPlayerId)) {
            endGame(casterPlayerId); // Fim de jogo, vencedor √© quem jogou
        } else {
            // Se n√£o venceu, avan√ßa o turno para o pr√≥ximo jogador
            // Passa `skipNextPlayer` para advanceTurn saber se precisa pular algu√©m extra
             // Passa `true` para checkPenalty para verificar UNO de quem acabou de jogar
            advanceTurn(true, skipNextPlayer);
        }
    }
}


/**
 * Processa a escolha de cor feita ap√≥s jogar uma carta Wild ou Wild4.
 * Atualiza a cor v√°lida, fecha o modal e avan√ßa o turno.
 * @param {string} chosenColor - A cor escolhida ('red', 'blue', 'green', 'yellow').
 * @param {number} chooserId - O ID do jogador que escolheu a cor.
 */
function handleColorChoice(chosenColor, chooserId) {
    // Valida√ß√£o
    if (gameOver) { console.log("handleColorChoice cancelado: Jogo finalizado."); return; }
    if (!chosenColor || !COLORS.includes(chosenColor)) {
        console.error("handleColorChoice: Escolha de cor inv√°lida ou cancelada.", chosenColor);
        // O que fazer aqui? Idealmente, for√ßar uma escolha ou pegar uma cor padr√£o.
        // Por simplicidade, se inv√°lido, vamos pegar uma aleat√≥ria.
        chosenColor = COLORS[Math.floor(Math.random() * COLORS.length)];
        console.warn("Cor inv√°lida recebida, escolhendo cor aleat√≥ria:", chosenColor);
    }
     if (wildColorChoiceCallback === null && chooserId === 0) {
         console.warn("handleColorChoice: Chamada inesperada sem callback pendente (jogador 0).");
         // Poderia ser um clique duplo no modal? Ignora se n√£o esperado.
         return;
     }
    if (botNextColorChoice === null && chooserId === 1) {
        console.warn("handleColorChoice: Chamada inesperada sem escolha pendente do bot (jogador 1).");
        return;
    }


    console.log(`Jogador ${chooserId} escolheu a cor: ${chosenColor}.`);
    currentValidColor = chosenColor; // Define a cor v√°lida para a pr√≥xima jogada

    // Limpa estado de espera pela cor
    wildColorChoiceCallback = null;
    botNextColorChoice = null;
    if (colorPickerModal) colorPickerModal.style.display = 'none'; // Fecha o modal

    // Atualiza a UI para refletir a cor escolhida (ex: brilho na carta do descarte)
    updateUI();

    const chooser = players[chooserId];
    const prefix = chooser?.isBot ? "O Bot escolheu a cor" : "Voc√™ escolheu a cor";
    let suffix = "";

    // Se a escolha veio de um +4 (ou +2 se bugado?), informa o pr√≥ximo jogador
    if (mustDrawCards > 0) {
        const nextPlayerIndex = (chooserId + gameDirection + players.length) % players.length;
        const nextPlayer = players[nextPlayerIndex];
        suffix = `! √â a vez de ${nextPlayer?.name}, jogue +${currentValidValue === 'draw2' ? 2 : 4} ou compre ${mustDrawCards}!`;
    } else {
        suffix = ". O jogo continua."; // Mensagem padr√£o
    }
    setStatusMessage(`${prefix} ${chosenColor.toUpperCase()}${suffix}`);

    // Importante: Verifica se quem jogou o Wild/Wild4 e escolheu a cor venceu
    if (checkWinCondition(chooserId)) {
        endGame(chooserId);
    } else {
        // Se n√£o venceu, avan√ßa o turno
        // Aqui, n√£o h√° skip (skipNextPlayer=false) vindo da escolha de cor
        // Checa penalidade de UNO de quem acabou de jogar? Sim (checkPenalty=true).
        advanceTurn(true, false);
    }
}

/**
 * Mostra o modal para o jogador humano escolher uma cor.
 * Bloqueia outras a√ß√µes enquanto o modal estiver ativo.
 * @param {function} callback - Fun√ß√£o a ser chamada com a cor escolhida.
 */
function promptColorChoice(callback) {
    if (gameOver || wildColorChoiceCallback) return; // N√£o abre se jogo acabou ou j√° tem um modal aberto

    console.log("Exibindo modal de escolha de cor para jogador humano.");
    wildColorChoiceCallback = callback; // Armazena o callback

    // Bloqueia intera√ß√µes do jogo enquanto escolhe
    if (drawCardBtn) drawCardBtn.disabled = true;
    if (unoBtn) { unoBtn.disabled = true; unoBtn.classList.remove('can-press'); }
    // Desabilita clique nas cartas da m√£o
    if (playerHandElement) {
        playerHandElement.querySelectorAll('.card').forEach(cardElem => {
            cardElem.style.pointerEvents = 'none'; // Impede clique
             cardElem.classList.remove('card--playable'); // Remove highlight
        });
    }
     if (deckPileElement) deckPileElement.style.cursor = 'default'; // Impede clique no deck

    // Mostra o modal
    if (colorPickerModal) colorPickerModal.style.display = 'flex';
}

/**
 * Fun√ß√£o chamada quando um bot√£o de cor no modal √© clicado.
 * Passa a cor escolhida para o callback armazenado.
 * @param {string} color - A cor do bot√£o clicado ('red', 'blue', etc.).
 */
function selectColor(color) {
    if (!gameOver && wildColorChoiceCallback) {
         console.log(`Jogador humano clicou na cor: ${color}`);
        wildColorChoiceCallback(color); // Chama o callback que estava esperando (handleColorChoice)
        wildColorChoiceCallback = null; // Limpa o callback ap√≥s usar
    } else {
        console.warn("selectColor chamado, mas n√£o havia callback esperando ou o jogo acabou.");
    }
}

/**
 * Passa o turno para o pr√≥ximo jogador na ordem atual.
 * Lida com pulos de carta, aplica compras for√ßadas e verifica penalidade de UNO.
 * @param {boolean} checkUnoPenaltyForPreviousPlayer - Se deve verificar a penalidade de UNO do jogador que acabou de jogar.
 * @param {boolean} cardEffectSkippedPlayer - Se o avan√ßo foi causado por uma carta Skip/Reverse(2p).
 */
function advanceTurn(checkUnoPenaltyForPreviousPlayer = true, cardEffectSkippedPlayer = false) {
    if (gameOver) return;

    const previousPlayerId = currentPlayerIndex;
    const previousPlayer = players[previousPlayerId];
    console.log(`--- Avan√ßando Turno de P${previousPlayerId} (${previousPlayer?.name}) ---`);
    console.log(`Detalhes: Checar Penalidade UNO=${checkUnoPenaltyForPreviousPlayer}, Pulo por Carta=${cardEffectSkippedPlayer}, Comprar Obrigat√≥rio=${mustDrawCards}, Dire√ß√£o=${gameDirection}`);

    // 1. Limpa indicador de turno ativo da UI
    playerZoneElement?.classList.remove('active-turn');
    opponentZoneElement?.classList.remove('active-turn');

    // 2. Checar Penalidade UNO do jogador ANTERIOR (se aplic√°vel)
    // Isso √© feito ANTES de mudar o currentPlayerIndex
    if (checkUnoPenaltyForPreviousPlayer) {
        checkUnoPenalty(previousPlayerId); // Verifica se esqueceu de gritar UNO
    }
    // Se a penalidade de UNO causou o fim do jogo (improv√°vel, mas poss√≠vel), para aqui.
    if(gameOver) return;

    // 3. Determinar o √çNDICE do PR√ìXIMO jogador
    let nextPlayerIndex = (previousPlayerId + gameDirection + players.length) % players.length;
    console.log(`Pr√≥ximo jogador (base): √çndice ${nextPlayerIndex}`);

    // Se o turno est√° avan√ßando porque uma carta Skip/Reverse(2p) foi jogada,
    // pula este jogador que seria o pr√≥ximo.
    if (cardEffectSkippedPlayer) {
        console.log(`Jogador ${nextPlayerIndex} (${players[nextPlayerIndex]?.name}) est√° sendo pulado devido a efeito de carta.`);
        setStatusMessage(`${players[nextPlayerIndex]?.name} perdeu a vez!`); // Mensagem mais clara sobre o pulo
        // Pula para o jogador seguinte na ordem
        nextPlayerIndex = (nextPlayerIndex + gameDirection + players.length) % players.length;
        console.log(`Jogador efetivamente pr√≥ximo ap√≥s o pulo: √çndice ${nextPlayerIndex}`);
        // Resetar flags de compra se pulamos algu√©m por carta (o pulado n√£o pode acumular)
        // playerMustPlayOrDraw = false; // N√£o resetar aqui, pode ter + acumulado pro proximo ainda? Sim. N√£o reseta.
        // mustDrawCards = 0; // N√£o reseta aqui. Se pulou alguem por skip normal, nao tinha + acumulado. Se foi skip sobre +2/4, nao devia ter pulado.
                           // O reset da compra ocorre se ela for EFETIVADA (compra for√ßada abaixo).
    }

    // 4. Atualizar o Jogador Atual
    currentPlayerIndex = nextPlayerIndex;
    const currentPlayer = players[currentPlayerIndex];
     if (!currentPlayer) { // Verifica√ß√£o de seguran√ßa
        console.error(`ERRO FATAL: Pr√≥ximo jogador (√çndice ${currentPlayerIndex}) √© inv√°lido!`);
        setStatusMessage("Erro cr√≠tico ao avan√ßar o turno!", true);
        endGame(null, true); return;
    }
    console.log(`>>> Agora √© a vez de P${currentPlayerIndex} (${currentPlayer.name}). M√£o: ${currentPlayer.hand.length}.`);

    // 5. Aplicar Indicador de Turno na UI para o NOVO jogador
    if (!gameOver) {
        if (currentPlayerIndex === 0) playerZoneElement?.classList.add('active-turn');
        else opponentZoneElement?.classList.add('active-turn');
    }

    // 6. Lidar com Compra Obrigat√≥ria para o Jogador ATUAL
    playerMustPlayOrDraw = (mustDrawCards > 0); // Confirma se AINDA h√° compra obrigat√≥ria para o jogador que acabou de receber a vez

    if (playerMustPlayOrDraw) {
        console.log(`Jogador ${currentPlayerIndex} enfrenta ${mustDrawCards} cartas para comprar.`);
        // Verifica se o jogador atual PODE jogar uma carta para evitar/acumular a compra
        // Pode jogar: Wild+4 (sempre) OU Draw+2 (se o √∫ltimo jogado foi Draw+2)
        const canCounter = currentPlayer.hand.some(card =>
            card && (card.value === 'wild4' || (card.value === 'draw2' && currentValidValue === 'draw2'))
        );

        if (canCounter) {
            // Se pode jogar, apenas informa o jogador
             setStatusMessage(`Vez de ${currentPlayer.name}! Jogue +${currentValidValue==='draw2'?2:4} ou compre ${mustDrawCards} cartas!`);
             console.log(`Jogador ${currentPlayerIndex} pode jogar +2 ou +4 para combater a compra.`);
             // N√£o faz mais nada, o jogador (ou bot) decidir√° na sua vez normal.
        } else {
            // Se N√ÉO pode jogar, for√ßa a compra e PASSA A VEZ
            console.log(`Jogador ${currentPlayerIndex} n√£o tem +2 ou +4. Compra for√ßada de ${mustDrawCards} cartas.`);
            setStatusMessage(`${currentPlayer.name} compra ${mustDrawCards} carta(s) e perde a vez.`);

            const cardsToDraw = mustDrawCards; // Guarda a quantidade antes de resetar
            mustDrawCards = 0;             // Reseta a contagem acumulada AP√ìS a compra
            playerMustPlayOrDraw = false;  // N√£o precisa mais jogar ou comprar ap√≥s a compra

            // Executa a compra (sem update da UI aqui para fazer junto com o avan√ßo)
            const drawnCount = drawCardFromDeck(currentPlayerIndex, cardsToDraw, false).length;

            // Verifica se a compra for√ßada causou fim do jogo (erro / empate)
            if(gameOver) return;

            // ATUALIZA a UI *antes* de passar o turno novamente (para mostrar cartas compradas)
            updateUI();

             // Delay leve para ver a compra e a mensagem antes de pular
             setTimeout(() => {
                 if (gameOver) return;
                console.log(`Passando a vez do Jogador ${currentPlayerIndex} que comprou ${drawnCount}/${cardsToDraw} cartas.`);
                // Pula a vez de quem comprou
                // N√£o precisa checar UNO de quem comprou (checkPenalty=false)
                // Simula um skip (cardEffectSkippedPlayer=true) para pular este jogador
                advanceTurn(false, true);
             }, 750); // Delay de 0.75s para o pulo

            return; // Retorna para n√£o executar o resto da fun√ß√£o (ativa√ß√£o do turno normal)
        }
    } else {
         // Se n√£o h√° compra obrigat√≥ria, apenas informa que √© a vez do jogador
         setStatusMessage(`√â a vez de ${currentPlayer.name}!`);
    }

    // 7. Atualizar a UI Geral (se n√£o foi atualizada pela compra for√ßada)
    // Isso √© importante para habilitar/desabilitar bot√µes e destacar cartas do humano
    if (!gameOver) { // Evita update desnecess√°rio se jogo j√° acabou
         updateUI();
    }


    // 8. Ativar o Turno do Jogador Atual (se n√£o houve compra for√ßada/pulo)
    if (currentPlayer.isBot && !botThinking && !gameOver) {
        botThinking = true;
        triggerBotTurn(); // Chama a l√≥gica do bot
    } else if (!currentPlayer.isBot && !gameOver) {
        botThinking = false; // Garante que flag est√° correta
        // updateUI() j√° foi chamado, jogador humano pode jogar
        console.log("Turno do jogador humano liberado.");
    }
    console.log(`--- Fim Advance Turn para P${currentPlayerIndex} ---`);
}


/**
 * Verifica se um jogador atingiu a condi√ß√£o de vit√≥ria (0 cartas na m√£o).
 * Aplica penalidade se esqueceu de gritar UNO.
 * @param {number} playerId - ID do jogador a verificar.
 * @returns {boolean} True se o jogador venceu, False caso contr√°rio.
 */
function checkWinCondition(playerId) {
    if (gameOver) return true; // Se jogo j√° acabou, considera "vit√≥ria" checada
    const player = players[playerId];
    if (!player) return false;

    // Condi√ß√£o principal: M√£o vazia
    if (player.hand.length === 0) {
        // Se chegou a 0 cartas, precisa ter gritado UNO na jogada anterior (quando ficou com 1)
        if (unoCalled[playerId]) {
            console.log(`üéâ CONDI√á√ÉO DE VIT√ìRIA ATINGIDA! Jogador ${playerId} (${player.name}) venceu com UNO chamado corretamente! üéâ`);
            return true; // Vit√≥ria confirmada!
        } else {
            // Esqueceu de gritar UNO quando ficou com 1 carta? Aplica penalidade.
            // canCallUno[playerId] deveria ser true aqui se ele TINHA 1 carta antes desta jogada
             // Mas mesmo se n√£o for (caso raro/bug), se tem 0 e n√£o gritou, penaliza.
            console.warn(`Jogador ${playerId} (${player.name}) jogou a √∫ltima carta, mas N√ÉO gritou UNO! Penalidade: +2 cartas.`);
            setStatusMessage(`${player.name} esqueceu de gritar UNO! Compra 2 cartas.`, true);
            drawCardFromDeck(playerId, 2, true); // Compra 2 cartas de penalidade
            // A compra pode fazer o jogo empatar se n√£o houver cartas, drawCard trata isso.
             if (gameOver) return true; // Se empatou, considera 'win checked'

            // Reseta flags UNO ap√≥s penalidade
            canCallUno[playerId] = false;
            unoCalled[playerId] = false;
             if(playerId === 0 && unoBtn) { unoBtn.disabled=true; unoBtn.classList.remove('can-press'); }

            return false; // N√£o venceu devido √† penalidade
        }
    }
    // Se ainda tem cartas na m√£o
    return false;
}

/**
 * Finaliza a partida, exibe a mensagem de vencedor ou empate e mostra bot√£o para reiniciar.
 * @param {number | null} winnerId - ID do jogador vencedor, ou null se for empate/erro.
 * @param {boolean} [isDrawOrError=false] - True se o jogo terminou em empate ou por erro irrecuper√°vel.
 */
function endGame(winnerId, isDrawOrError = false) {
     if (gameOver) return; // Evita execu√ß√µes m√∫ltiplas
     gameOver = true;
     botThinking = false; // Para qualquer processamento do bot
     console.log("================ FIM DE JOGO ================");

     // 1. Limpar Indicadores Visuais de Jogo Ativo
     playerZoneElement?.classList.remove('active-turn', 'has-uno');
     opponentZoneElement?.classList.remove('active-turn', 'has-uno');

     // 2. Desabilitar Intera√ß√µes do Jogo
     if (drawCardBtn) drawCardBtn.disabled = true;
     if (unoBtn) { unoBtn.disabled = true; unoBtn.classList.remove('can-press'); }
     // Remove interatividade das cartas do jogador
     playerHandElement?.querySelectorAll('.card').forEach(card => {
         card.style.pointerEvents = 'none';
         card.classList.remove('card--playable');
         card.style.cursor = 'default';
     });
     // Remove interatividade do monte de compra
     if (deckPileElement) deckPileElement.style.cursor = 'default';
     // Fecha o modal de cor, caso esteja aberto
     if (colorPickerModal) colorPickerModal.style.display = 'none';
      wildColorChoiceCallback = null; // Limpa callback pendente

     // 3. Definir Mensagem Final
     let finalMsg = "Fim de Jogo!";
     let isWinner = false;
     if (isDrawOrError) {
         // Se for erro cr√≠tico, a mensagem pode j√° ter sido definida como erro
         if (!gameStatusElement?.classList.contains('error-message')) {
            finalMsg = "EMPATE! üè≥Ô∏è Ningu√©m venceu.";
         } else {
             finalMsg = gameStatusElement.firstChild?.textContent || "Erro cr√≠tico! Fim de Jogo."; // Mant√©m msg de erro se j√° definida
         }
         console.log("Jogo finalizado sem vencedor (Empate ou Erro).");
     } else if (winnerId !== null && players[winnerId]) {
         const winner = players[winnerId];
         finalMsg = `üéâ ${winner.name.toUpperCase()} VENCEU! üéâ`;
         isWinner = true;
         console.log(`Vencedor: Jogador ${winnerId} (${winner.name})`);
         // Limpa visualmente a m√£o do vencedor
         if (winnerId === 0 && playerHandElement) {
            // Efeito visual opcional de cartas "voando"
            Array.from(playerHandElement.children).forEach((cardEl, index) => {
                cardEl.style.animation = `card-fly-out 0.5s ${index * 0.05}s ease-out forwards`;
            });
            setTimeout(() => { if (playerHandElement) playerHandElement.innerHTML = ''; }, 500 + playerHandElement.children.length * 50); // Limpa ap√≥s anima√ß√£o
         } else if (winnerId === 1 && opponentHandElement) {
            opponentHandElement.setAttribute('data-count', '0'); // Zera contador do bot
             opponentHandElement.style.opacity = '0'; // Esconde carta placeholder
             setTimeout(() => { if(opponentHandElement) opponentHandElement.style.opacity = '1';}, 1000); // Reaparece depois (opcional)
         }
     } else {
         console.log("Fim de jogo chamado sem um vencedor claro ou empate/erro.");
         // Mant√©m a mensagem padr√£o "Fim de Jogo!"
     }

     // 4. Exibir Mensagem Final no Status
      // Limpa timers pendentes (ex: bot pensando) - A flag gameOver deve fazer isso, mas garantia extra.
     // clearTimeout(botTimer); // Se estivesse usando um timer expl√≠cito
     setStatusMessage(finalMsg, gameStatusElement?.classList.contains('error-message'), isWinner); // Usa isWinner para aplicar classe de vencedor

     // 5. Adicionar Bot√£o "Jogar Novamente" na √°rea de status (se n√£o existir)
     let restartBtnStatus = gameStatusElement?.querySelector('.btn--restart');
     if (gameStatusElement && !restartBtnStatus) {
         // Adiciona uma quebra de linha antes do bot√£o para espa√ßamento
         const br = document.createElement('br');
         gameStatusElement.appendChild(br);
         // Cria o bot√£o
         restartBtnStatus = document.createElement('button');
         restartBtnStatus.textContent = 'Jogar Novamente';
         restartBtnStatus.className = 'btn btn--restart'; // Classe espec√≠fica para este bot√£o
         restartBtnStatus.onclick = startGame; // Reatribui o evento de clique para reiniciar
         gameStatusElement.appendChild(restartBtnStatus);
         console.log("Bot√£o 'Jogar Novamente' adicionado √† √°rea de status.");
     }
     // Garante que o bot√£o de reiniciar do TOPO ainda funcione
      if(restartGameBtnTop) restartGameBtnTop.disabled = false;
}


/**
 * Atualiza todos os componentes visuais da interface do jogo.
 * M√£os dos jogadores, pilhas de descarte/compra, bot√µes, status, etc.
 */
function updateUI() {
    // N√£o atualiza se o jogo acabou (exceto para o estado final em endGame)
    if (gameOver && !gameStatusElement?.querySelector('.btn--restart')) { // Permite √∫ltimo update do endGame
       // console.log("updateUI bloqueado: Jogo finalizado."); // Log muito frequente, desabilitar
       return;
    }
    // Valida√ß√£o b√°sica dos dados
     if (!players || players.length < 2 || !discardPile || !deck) {
        console.error("updateUI: Dados de jogo inv√°lidos ou incompletos.");
        return;
     }

    // 1. Renderizar √°reas principais
    renderPlayerHand();     // M√£o do jogador humano
    renderOpponentHand();   // Contador de cartas do bot
    renderDiscardPile();    // Carta do topo e efeito de pilha
    renderDeckPile();       // Baralho (carta virada ou placeholder)

    // 2. Atualizar Estado Visual dos Jogadores (Badges UNO)
    // Jogador Humano
    const playerHasUnoState = players[0]?.hand.length === 1 && unoCalled[0];
    if (playerZoneElement) playerZoneElement.classList.toggle('has-uno', playerHasUnoState);
    // Bot
    const botHasUnoState = players[1]?.hand.length === 1 && unoCalled[1];
     if (opponentZoneElement) opponentZoneElement.classList.toggle('has-uno', botHasUnoState);


    // 3. Atualizar Estado dos Bot√µes de A√ß√£o e Destaques (Jogador Humano)
    if (currentPlayerIndex === 0 && !botThinking && !gameOver) { // Vez do humano, bot n√£o pensando, jogo ativo
        // Bot√£o Comprar Carta
        const canDrawFromDeck = deck.length > 0 || discardPile.length > 1; // Pode comprar OU reembaralhar
        if (drawCardBtn) {
             // Habilitado SE N√ÉO for obrigado a jogar/comprar (+acumulado) E SE houver cartas para comprar/reembaralhar
             drawCardBtn.disabled = playerMustPlayOrDraw || !canDrawFromDeck;
             // Texto do bot√£o pode mudar se for reembaralhar? N√£o, handleDrawClick trata isso.
        }

        // Bot√£o UNO!
        if (unoBtn) {
            // Habilitado SE PODE gritar (tem 1 carta) E AINDA N√ÉO gritou
            const canPressUno = canCallUno[0] && !unoCalled[0];
            unoBtn.disabled = !canPressUno;
            unoBtn.classList.toggle('can-press', canPressUno); // Aplica/remove classe para anima√ß√£o/estilo
        }

        // Destacar cartas jog√°veis na m√£o
        highlightPlayableCards();

         // Habilitar/Desabilitar clique no Deck Pile
        if (deckPileElement) deckPileElement.style.cursor = !playerMustPlayOrDraw && canDrawFromDeck ? 'pointer' : 'default';

    } else { // N√£o √© a vez do humano OU bot est√° pensando OU jogo acabou
        // Desabilitar tudo
        if (drawCardBtn) drawCardBtn.disabled = true;
        if (unoBtn) {
            unoBtn.disabled = true;
            unoBtn.classList.remove('can-press');
        }
        // Remover destaque e pointer events das cartas
        playerHandElement?.querySelectorAll('.card').forEach(cardElem => {
             cardElem.classList.remove('card--playable');
             cardElem.style.pointerEvents = 'none';
             cardElem.style.cursor = 'default';
        });
        if (deckPileElement) deckPileElement.style.cursor = 'default';
    }

    // 4. Garantir que Modal de Cor est√° fechado se n√£o for necess√°rio
    if (!wildColorChoiceCallback && colorPickerModal && colorPickerModal.style.display !== 'none') {
        colorPickerModal.style.display = 'none';
    }
}


/** Renderiza as cartas na m√£o do jogador humano. */
function renderPlayerHand() {
    if (!playerHandElement || !players?.[0]) return;
    const hand = players[0].hand;
    // Usar DocumentFragment para performance ao adicionar m√∫ltiplos elementos
    const frag = document.createDocumentFragment();
    hand.forEach(card => {
        if (card) {
            // O terceiro argumento true indica que √© uma carta na m√£o do jogador (adiciona listener)
            frag.appendChild(createCardElement(card, card.id, true));
        } else {
             console.warn("Carta nula/inv√°lida encontrada na m√£o do jogador 0.");
        }
    });
    playerHandElement.innerHTML = ''; // Limpa m√£o antiga
    playerHandElement.appendChild(frag); // Adiciona todas as novas cartas
}

/** Renderiza o verso da carta do oponente com a contagem de cartas. */
function renderOpponentHand() {
    if (opponentHandElement && players?.[1]) {
        const handSize = players[1].hand.length;
        opponentHandElement.setAttribute('data-count', String(Math.max(0, handSize)));
         // Mostra/Esconde a carta placeholder se o bot tiver 0 cartas
        opponentHandElement.style.display = handSize > 0 ? 'flex' : 'none';
        if (handSize === 0 && opponentZoneElement?.querySelector('.hand-area')) {
             // Opcional: Adicionar um placeholder se a m√£o est√° vazia?
            // opponentZoneElement.querySelector('.hand-area').innerHTML = '<div class="card--placeholder">Vazio</div>';
        } else if (handSize > 0 && opponentZoneElement?.querySelector('.hand-area .card--placeholder')) {
            // Remover placeholder se existia
           // const placeholder = opponentZoneElement.querySelector('.hand-area .card--placeholder');
           // if(placeholder) placeholder.remove();
        }
    } else if (opponentHandElement) {
        // Estado inicial ou erro, esconde ou mostra contagem 0
        opponentHandElement.setAttribute('data-count', '0');
        opponentHandElement.style.display = 'none';
    }
}

/** Renderiza a pilha de descarte com a carta do topo e efeito visual de pilha. */
function renderDiscardPile() {
    if (!discardPileElement) return;
    discardPileElement.innerHTML = ''; // Limpa √°rea de descarte

    if (discardPile.length === 0) {
        // Se vazia, mostra placeholder
        discardPileElement.innerHTML = '<div class="card card--placeholder"><span>Descarte</span></div>';
        return;
    }

    // Pega a carta do topo
    const topCard = discardPile[discardPile.length - 1];
    if (!topCard) { // Verifica√ß√£o de seguran√ßa
         console.error("renderDiscardPile: Top card inv√°lido ou nulo.");
         discardPileElement.innerHTML = '<div class="card card--placeholder"><span>Erro</span></div>';
         return;
     }

    // Cria o elemento HTML para a carta do topo
    // O ID DOM √© diferenciado para n√£o conflitar com cartas na m√£o
    const topElem = createCardElement(topCard, topCard.id + '-discard', false); // false = n√£o √© clic√°vel na m√£o
    topElem.style.position = 'relative'; // Para z-index funcionar e badge posicionar
    topElem.style.zIndex = '1';       // Garante que fique acima das cartas "empilhadas"

    // Adiciona brilho baseado na cor v√°lida atual (se for uma cor do jogo)
    if (currentValidColor && COLORS.includes(currentValidColor)) {
        topElem.style.boxShadow = `0 0 10px 3px var(--uno-${currentValidColor}), 3px 3px 5px rgba(0,0,0,.3)`;
        topElem.style.borderColor = `var(--uno-${currentValidColor})`;
        // Classe CSS tamb√©m pode controlar isso (ver style.css -> discard-pile > .card:last-child[style*="box-shadow"])
    } else {
         topElem.style.boxShadow = '3px 3px 5px rgba(0,0,0,.3)'; // Sombra padr√£o
         topElem.style.borderColor = 'var(--card-border)';
    }


    // Adiciona badge de +X se houver compra acumulada
    if (mustDrawCards > 0) {
        const badge = document.createElement('div');
        badge.className = 'draw-count-badge';
        badge.textContent = `+${mustDrawCards}`;
        topElem.appendChild(badge);
    }

    // Cria efeito de pilha com as cartas abaixo do topo (m√°x 2 para visual)
    const stackFrag = document.createDocumentFragment();
    const numStacked = Math.min(discardPile.length - 1, 2); // Mostra at√© 2 cartas abaixo
    for (let i = 1; i <= numStacked; i++) {
        const belowCard = discardPile[discardPile.length - 1 - i];
        if (!belowCard) continue; // Pula se carta for inv√°lida
        // Cria elemento para carta "abaixo"
        const belowElem = createCardElement(belowCard, belowCard.id + '-stack-' + i, false);
        // Estilos para criar o efeito de pilha via CSS seria melhor, mas aqui um exemplo inline:
        belowElem.style.position = 'absolute';
        belowElem.style.top = '0'; belowElem.style.left = '0'; // Alinha com o container
        belowElem.style.zIndex = `${-i}`; // Empilha para tr√°s
        belowElem.style.opacity = `${1 - (i * 0.3)}`; // Mais transparente quanto mais fundo
        // Transforma√ß√£o para parecer desalinhado (usando nth-child no CSS √© mais limpo)
         belowElem.style.transform = `translateX(${i * (i % 2 === 0 ? -1 : 1) * 2.5}px) translateY(${i * 2.5}px) rotate(${(i % 2 === 0 ? -1 : 1) * i * 3}deg)`;
         belowElem.style.filter = `blur(${i*0.5}px)`; // Efeito de blur
         stackFrag.appendChild(belowElem);
    }

    // Adiciona primeiro as cartas empilhadas (fundo) e depois a do topo
    discardPileElement.appendChild(stackFrag);
    discardPileElement.appendChild(topElem);
}

/** Renderiza a pilha de compra (deck) - mostra verso ou placeholder. */
function renderDeckPile() {
    if (!deckPileElement) return;
    deckPileElement.innerHTML = ''; // Limpa √°rea do deck

    if (deck.length > 0) {
        // Se h√° cartas no deck, mostra o verso da carta
        const backCard = document.createElement('div');
        backCard.className = 'card card--back';
        // Adiciona ID ou data attribute se precisar referenciar depois
        backCard.id = 'deck-back-card';
        deckPileElement.appendChild(backCard);
        deckPileElement.style.display = 'block'; // Garante visibilidade

        // Define cursor e t√≠tulo baseado na possibilidade de comprar
        const canDrawNow = (currentPlayerIndex === 0 && !botThinking && !playerMustPlayOrDraw && !gameOver);
        deckPileElement.style.cursor = canDrawNow ? 'pointer' : 'default';
        deckPileElement.title = canDrawNow ? 'Comprar Carta' : 'Baralho';

    } else {
        // Se deck est√° vazio, verifica se PODE reembaralhar
        const canReshuffle = discardPile.length > 1;
        if (canReshuffle) {
            // Mostra placeholder indicando que pode reembaralhar ao clicar
            deckPileElement.innerHTML = '<div class="card card--placeholder card--reshuffle"><span>Baralho Vazio<br>(Clique para Reembaralhar e Comprar)</span></div>';
            deckPileElement.style.display = 'block';
             // Permite clicar para reembaralhar apenas na vez do humano, se n√£o obrigado a jogar +
            const canClickReshuffle = (currentPlayerIndex === 0 && !botThinking && !playerMustPlayOrDraw && !gameOver);
            deckPileElement.style.cursor = canClickReshuffle ? 'pointer' : 'default';
            deckPileElement.title = canClickReshuffle ? 'Reembaralhar e Comprar Carta' : 'Baralho Vazio';
        } else {
            // Se n√£o pode reembaralhar (poucas cartas no descarte), esconde o deck pile
            deckPileElement.style.display = 'none';
             console.log("Render deck: Vazio e imposs√≠vel reembaralhar.");
        }
    }
}

/**
 * Cria e retorna um elemento DIV HTML representando uma carta de UNO.
 * @param {Object} card - O objeto da carta com 'color', 'value', 'id', 'type'.
 * @param {string} elementDomId - ID √∫nico para ser atribu√≠do ao elemento no DOM.
 * @param {boolean} [isPlayerCard=false] - Se true, adiciona event listener de clique para jogar (s√≥ para cartas da m√£o humana).
 * @returns {HTMLDivElement} O elemento da carta criado.
 */
function createCardElement(card, elementDomId, isPlayerCard = false) {
    // Valida√ß√£o da carta
    if (!card || !card.id || !card.value || !card.color) {
        console.error("createCardElement: Dados da carta inv√°lidos.", card);
        const errorDiv = document.createElement('div'); errorDiv.textContent = 'Erro'; return errorDiv;
    }

    const cardElem = document.createElement('div');
    cardElem.className = 'card'; // Classe base
    cardElem.dataset.id = card.id; // Guarda ID original da carta nos dados
    cardElem.id = `card-dom-${elementDomId}`; // ID √∫nico para o elemento DOM

    // Elemento interno para o valor/√≠cone
    const valueSpan = document.createElement('span');
    valueSpan.className = 'value';
    // Adicionado sempre, conte√∫do definido abaixo

    // Aplicar classes CSS baseadas na cor e tipo/valor
    if (card.color === 'special') {
        cardElem.classList.add('card--special', `card--${card.value}`); // Wild, Wild4
        // Texto para coringas √© definido via ::after no CSS
    } else {
        // Cartas Coloridas
        cardElem.classList.add(`card--${card.color}`);
        // Verifica se √© n√∫mero ou a√ß√£o
        if (isNaN(parseInt(card.value))) { // N√£o √© n√∫mero -> A√ß√£o (skip, reverse, draw2)
             cardElem.classList.add('card--special', `card--${card.value}`);
            // √çcones para a√ß√µes s√£o definidos via ::after no CSS
        } else { // √â n√∫mero
            valueSpan.textContent = card.value; // Mostra o n√∫mero
        }
    }
    cardElem.appendChild(valueSpan); // Adiciona span de valor/√≠cone √† carta

    // Adicionar Event Listener de Clique (SOMENTE para cartas na M√ÉO do jogador 0)
    if (isPlayerCard && playerHandElement && players?.[0]?.hand.some(handCard => handCard && handCard.id === card.id)) {
         cardElem.addEventListener('click', () => {
            // Verifica se o jogo permite a a√ß√£o
            if (!gameOver && currentPlayerIndex === 0 && !botThinking) {
                 // Encontra o √≠ndice real da carta na m√£o atual do jogador
                const cardId = cardElem.dataset.id;
                const currentHand = players[0].hand;
                const cardIndexInHand = currentHand.findIndex(hCard => hCard && hCard.id === cardId);

                if (cardIndexInHand !== -1) {
                     console.log(`Jogador clicou na carta: ${cardId} (√çndice na m√£o: ${cardIndexInHand})`);
                     playCard(0, cardIndexInHand); // Tenta jogar a carta
                 } else {
                    console.error(`Erro no clique: Carta com ID ${cardId} (DOM id ${cardElem.id}) n√£o encontrada na m√£o atual do jogador 0. M√£o:`, currentHand);
                    setStatusMessage("Erro: Carta n√£o encontrada na m√£o.", true);
                 }

             } else {
                 // Informa porque o clique foi ignorado
                 if (gameOver) setStatusMessage("O jogo j√° terminou.", true);
                 else if (currentPlayerIndex !== 0) setStatusMessage("N√£o √© a sua vez!", true);
                 else if (botThinking) setStatusMessage("Aguarde o Bot terminar a jogada.", true);
                 // Adiciona um pequeno 'shake' visual para feedback
                 cardElem.style.animation = 'shake 0.3s ease-in-out';
                 setTimeout(() => cardElem.style.animation = '', 300);
             }
         });
         // O cursor pointer √© definido/removido em highlightPlayableCards
         cardElem.style.cursor = 'default'; // Come√ßa como n√£o jog√°vel at√© highlight verificar
    } else {
         // Cartas no descarte, etc., n√£o s√£o clic√°veis
         cardElem.style.cursor = 'default';
    }

    return cardElem;
}


/** Destaca as cartas jog√°veis na m√£o do jogador humano adicionando uma classe CSS. */
function highlightPlayableCards() {
    // Executa somente se for a vez do humano, o bot n√£o estiver pensando, e o jogo n√£o acabou
    if (gameOver || currentPlayerIndex !== 0 || botThinking || !playerHandElement || !players?.[0]) {
        // Garante que nenhuma carta fique destacada se n√£o for a vez do humano
        playerHandElement?.querySelectorAll('.card.card--playable').forEach(elem => {
            elem.classList.remove('card--playable');
            elem.style.cursor = 'default';
        });
        return;
    }

    const playerHand = players[0].hand;
    playerHandElement.querySelectorAll('.card').forEach(cardElem => {
        const cardId = cardElem.dataset.id;
        // Encontra a carta correspondente nos dados da m√£o do jogador
        const cardData = playerHand.find(c => c && c.id === cardId);
        let isPlayable = false;

        // Verifica se a carta existe e se √© jog√°vel
        if (cardData) {
             isPlayable = isCardPlayable(cardData);
        }

        // Adiciona ou remove a classe de destaque
        cardElem.classList.toggle('card--playable', isPlayable);
        // Define o cursor para indicar interatividade
        cardElem.style.cursor = isPlayable ? 'pointer' : 'default';
         // Garante que o pointerEvents n√£o esteja bloqueado (pode ser redefinido pelo modal)
         cardElem.style.pointerEvents = 'auto';
    });
}


/**
 * Define a mensagem exibida na √°rea de status do jogo.
 * Pode aplicar classes para estiliza√ß√£o (erro, vencedor, etc.).
 * @param {string} msg - A mensagem a ser exibida.
 * @param {boolean} [isError=false] - Se true, aplica estilo de erro.
 * @param {boolean} [isWinner=false] - Se true, aplica estilo de vencedor.
 */
function setStatusMessage(msg, isError = false, isWinner = false) {
    if (!gameStatusElement) return;

    // Guarda o bot√£o de reiniciar (se existir) para readicion√°-lo depois
    const restartButton = gameStatusElement.querySelector('.btn--restart');
    const lineBreak = gameStatusElement.querySelector('br'); // Guarda tamb√©m o <br>

    // Limpa apenas o conte√∫do de TEXTO atual, preservando o bot√£o/br
    Array.from(gameStatusElement.childNodes).forEach(node => {
        // Remove n√≥s de texto e elementos que n√£o sejam o bot√£o/br guardados
        if (node.nodeType === Node.TEXT_NODE || (node !== restartButton && node !== lineBreak)) {
            gameStatusElement.removeChild(node);
        }
    });

    // Cria e insere o novo n√≥ de texto no in√≠cio
    const textNode = document.createTextNode(msg);
    gameStatusElement.insertBefore(textNode, gameStatusElement.firstChild);

    // Aplica classes de estilo baseadas no tipo de mensagem
    gameStatusElement.className = 'game-status'; // Reseta classes antigas
    if (isWinner) {
        gameStatusElement.classList.add('winner-message');
    } else if (isError) {
        gameStatusElement.classList.add('error-message');
    } else if (msg.toLowerCase().includes("vez de")) {
        gameStatusElement.classList.add('player-turn');
    } else if (msg.toLowerCase().includes("uno!")) {
        gameStatusElement.classList.add('uno-alert');
    }
     // Adiciona outras classes condicionais se necess√°rio (ex: 'thinking-message')

     // Readiciona o <br> e o bot√£o de reiniciar, se existiam
     if (lineBreak) gameStatusElement.appendChild(lineBreak);
     if (restartButton) gameStatusElement.appendChild(restartButton);

    // Loga a mensagem no console para debug
    console.log("Status:", msg);
}


// ===== L√≥gica da IA (Bot) =====

/** Ativa o turno do bot ap√≥s um pequeno delay (simula pensamento). */
function triggerBotTurn() {
    // Valida√ß√µes para garantir que o bot DEVE jogar
    if (gameOver || currentPlayerIndex !== 1 || !players[1]?.isBot || !botThinking) {
        botThinking = false; // Corrige flag se chamada indevida
        console.warn("triggerBotTurn cancelado: Condi√ß√µes n√£o atendidas.", {gameOver, currentPlayerIndex, isBot: players[1]?.isBot, botThinking});
        // Se a vez voltou pro humano inesperadamente, atualiza a UI dele
        if (!gameOver && currentPlayerIndex === 0) updateUI();
        return;
    }

    console.log("Bot est√° 'pensando'...");
    setStatusMessage("Bot est√° pensando..."); // Informa o jogador humano

    // Adiciona delay
    setTimeout(() => {
        // Revalida as condi√ß√µes DENTRO do timeout, pois o estado pode ter mudado
        if (!gameOver && currentPlayerIndex === 1 && players[1]?.isBot && botThinking) {
            executeBotLogic();
        } else {
            console.log("A√ß√£o do Bot cancelada: Estado do jogo mudou durante o 'pensamento'.");
            // Se o jogo acabou ou n√£o √© mais vez do bot, reseta flag
            if(gameOver || currentPlayerIndex !== 1) botThinking = false;
             // Se a vez voltou pro humano, atualiza a UI
             if (!gameOver && currentPlayerIndex === 0) updateUI();
        }
    }, BOT_TURN_DELAY_MS); // Usa a constante para o delay
}

/** Executa a l√≥gica de decis√£o e jogada do bot. */
function executeBotLogic() {
    // Valida√ß√£o final antes da execu√ß√£o
    if (gameOver || currentPlayerIndex !== 1 || !players[1]?.isBot) {
        console.error("executeBotLogic chamada, mas condi√ß√µes n√£o s√£o mais v√°lidas.");
        botThinking = false; return;
    }

    console.log("--- Executando L√≥gica do Bot ---");
    const bot = players[1];
    const botHand = bot.hand;

    // 1. A√ß√£o Obrigat√≥ria (+2/+4)? Tentar contra-atacar.
    if (playerMustPlayOrDraw) {
        console.log(`Bot enfrenta compra obrigat√≥ria de ${mustDrawCards}. Verificando contra-ataque...`);
         // Prioriza jogar +4 se tiver
        const wild4Card = botHand.find(c => c && c.value === 'wild4');
        if (wild4Card) {
             const index = botHand.findIndex(c => c && c.id === wild4Card.id);
             console.log(`Bot joga ${wild4Card.id} (+4) para contra-atacar!`);
             playCard(1, index); // playCard lidar√° com escolha de cor e avan√ßo
             botThinking = false; // Reseta flag ap√≥s jogada
             return;
         }
         // Sen√£o, tenta jogar +2 se for v√°lido (topo √© +2)
        const draw2Card = botHand.find(c => c && c.value === 'draw2' && currentValidValue === 'draw2');
        if (draw2Card) {
             const index = botHand.findIndex(c => c && c.id === draw2Card.id);
             console.log(`Bot joga ${draw2Card.id} (+2) para acumular!`);
             playCard(1, index);
             botThinking = false;
             return;
         }
        // Se n√£o pode contra-atacar, a compra ser√° for√ßada pelo advanceTurn.
        // N√£o precisamos chamar drawCard aqui, o fluxo normal cuidar√° disso.
        console.log("Bot n√£o pode contra-atacar a compra obrigat√≥ria. Compra ser√° for√ßada.");
        // Bot 'passa' a vez, o advanceTurn que o chamou vai for√ßar a compra e pular.
        // IMPORTANTE: N√£o chamar advanceTurn daqui, sen√£o entra em loop. Apenas sai.
        botThinking = false; // Reseta flag
        // O fluxo normal do advanceTurn (que foi interrompido pela compra for√ßada) vai continuar
        return;
    }

    // 2. Turno Normal: Encontrar a melhor carta para jogar.
    // Mapeia todas as cartas jog√°veis
    const playableCards = botHand.map((card, index) => ({ card, index })).filter(item => item.card && isCardPlayable(item.card));

    if (playableCards.length > 0) {
        console.log(`Bot tem ${playableCards.length} cartas jog√°veis:`, playableCards.map(pc => pc.card.id));
        let chosenCardData = null;

        // --- Estrat√©gia de Escolha Simples ---
        // Prioridade:
        // 1. Cartas de A√ß√£o (Skip, Reverse, Draw2) da mesma COR que o topo.
        // 2. Cartas Num√©ricas da mesma COR que o topo.
        // 3. Cartas de A√ß√£o do mesmo VALOR que o topo (cor diferente).
        // 4. Cartas Num√©ricas do mesmo VALOR que o topo (cor diferente).
        // 5. Cartas de A√ß√£o (qualquer uma que seja jog√°vel).
        // 6. Cartas Num√©ricas (qualquer uma que seja jog√°vel).
        // 7. Cartas Wild (Coringa Normal).
        // 8. Cartas Wild +4 (se for a √∫nica op√ß√£o ou estrat√©gia agressiva).

        // Filtra tipos para estrat√©gia
        const matchingColorActions = playableCards.filter(d => d.card.type === 'action' && d.card.color === currentValidColor);
        const matchingColorNumbers = playableCards.filter(d => d.card.type !== 'action' && d.card.type !== 'wild' && d.card.color === currentValidColor);
        const matchingValueActions = playableCards.filter(d => d.card.type === 'action' && d.card.value === currentValidValue && d.card.color !== currentValidColor);
        const matchingValueNumbers = playableCards.filter(d => d.card.type !== 'action' && d.card.type !== 'wild' && d.card.value === currentValidValue && d.card.color !== currentValidColor);
        const anyPlayableAction = playableCards.filter(d => d.card.type === 'action');
        const anyPlayableNumber = playableCards.filter(d => d.card.type !== 'action' && d.card.type !== 'wild');
        const wilds = playableCards.filter(d => d.card.value === 'wild');
        const wild4s = playableCards.filter(d => d.card.value === 'wild4');

        if (matchingColorActions.length > 0) chosenCardData = matchingColorActions[0]; // Prioriza a√ß√£o da mesma cor
        else if (matchingColorNumbers.length > 0) chosenCardData = matchingColorNumbers[0]; // Num da mesma cor
        else if (matchingValueActions.length > 0) chosenCardData = matchingValueActions[0]; // A√ß√£o do mesmo valor
        else if (matchingValueNumbers.length > 0) chosenCardData = matchingValueNumbers[0]; // Num do mesmo valor
        else if (anyPlayableAction.length > 0) chosenCardData = anyPlayableAction[0];       // Qualquer a√ß√£o jog√°vel
        else if (anyPlayableNumber.length > 0) chosenCardData = anyPlayableNumber[0];       // Qualquer n√∫mero jog√°vel
        else if (wilds.length > 0) chosenCardData = wilds[0];                               // Coringa normal
        else if (wild4s.length > 0) chosenCardData = wild4s[0];                             // Coringa +4 (√∫ltimo recurso)
        else {
             // Fallback muito improv√°vel se playableCards.length > 0
             console.error("Bot: Falha na l√≥gica de escolha, usando a primeira jog√°vel como fallback.");
             chosenCardData = playableCards[0];
         }

        console.log(`Bot escolheu jogar: ${chosenCardData.card.id} (√çndice ${chosenCardData.index})`);
        // Joga a carta escolhida
        playCard(1, chosenCardData.index);
        botThinking = false; // Reseta flag

    } else {
        // 3. Se n√£o h√° cartas jog√°veis: Comprar uma carta.
        console.log("Bot n√£o tem cartas jog√°veis. Comprando uma carta...");
        setStatusMessage("Bot est√° comprando uma carta...");
        const drawnCards = drawCardFromDeck(1, 1, false); // Compra 1, sem update imediato

        if(gameOver) return; // Compra pode ter causado fim

        if (drawnCards.length > 0) {
            const drawnCard = drawnCards[0];
            console.log(`Bot comprou: ${drawnCard.id}`);
            // Verifica se a carta comprada PODE ser jogada IMEDIATAMENTE
            if (isCardPlayable(drawnCard)) {
                console.log(`Carta comprada (${drawnCard.id}) √© jog√°vel! Jogando...`);
                 // A carta est√° no fim da m√£o agora. Precisa do √≠ndice correto.
                 const drawnCardIndex = bot.hand.findIndex(c => c && c.id === drawnCard.id);
                 if (drawnCardIndex !== -1) {
                     setStatusMessage("Bot jogou a carta que acabou de comprar!");
                     // Pequeno delay antes de jogar a carta comprada
                     setTimeout(() => {
                         if(gameOver || currentPlayerIndex !== 1) return; // Revalida
                          playCard(1, drawnCardIndex);
                         botThinking = false; // Reseta flag AP√ìS jogar
                     }, 750); // Delay de 0.75s
                 } else {
                     console.error("Bot: Carta comprada n√£o encontrada na m√£o para jogar?");
                     setStatusMessage("Bot comprou e passou a vez."); // Passa se bug
                      botThinking = false; advanceTurn(true, false);
                 }
            } else {
                // Se a carta comprada n√£o √© jog√°vel, passa a vez
                console.log("Carta comprada n√£o √© jog√°vel. Bot passa a vez.");
                setStatusMessage("Bot comprou uma carta e passou a vez.");
                botThinking = false;
                updateUI(); // Atualiza para mostrar a carta comprada antes de passar
                advanceTurn(true, false); // Avan√ßa o turno (checa UNO do bot)
            }
        } else {
            // Se n√£o conseguiu comprar (deck e descarte vazios), o jogo j√° deve ter acabado (empate).
            // Mas por seguran√ßa, passa a vez.
             console.log("Bot n√£o conseguiu comprar (sem cartas?). Passando a vez.");
             setStatusMessage("Bot n√£o conseguiu comprar. Passou a vez.", true);
             botThinking = false;
             updateUI();
             advanceTurn(true, false);
        }
    }
    console.log("--- Fim da L√≥gica do Bot ---");
}

/**
 * IA (simples) do Bot para escolher a melhor cor ao jogar um Wild/Wild4.
 * Escolhe a cor que mais possui na m√£o (excluindo coringas).
 * @returns {string} A cor escolhida ('red', 'blue', 'green', 'yellow').
 */
function chooseBotColor() {
    const botHand = players[1]?.hand;
    // Se m√£o inv√°lida ou vazia, escolhe aleat√≥rio
    if (!botHand || botHand.length === 0) {
        const randomColor = COLORS[Math.floor(Math.random() * COLORS.length)];
        console.log(`Escolha de cor (Bot - m√£o vazia/inv√°lida): Aleat√≥ria -> ${randomColor}`);
        return randomColor;
    }

    // Conta quantas cartas de cada cor o bot possui
    const colorCounts = { red: 0, blue: 0, green: 0, yellow: 0 };
    botHand.forEach(card => {
        if (card && card.color !== 'special') { // Ignora coringas na contagem
            if (COLORS.includes(card.color)) {
                colorCounts[card.color]++;
            }
        }
    });

    let bestColor = '';
    let maxCount = -1;
    const tiedColors = []; // Para lidar com empates

     console.log("Contagem de cores do Bot:", colorCounts);

    // Encontra a cor(es) com maior contagem
    for (const color in colorCounts) {
        if (colorCounts[color] > maxCount) {
            maxCount = colorCounts[color];
            tiedColors.length = 0; // Limpa array de empates
            tiedColors.push(color);
        } else if (colorCounts[color] === maxCount) {
            tiedColors.push(color); // Adiciona ao empate
        }
    }

    // Decide a cor
    if (maxCount <= 0) { // Se n√£o tem nenhuma carta colorida (s√≥ coringas)
        bestColor = COLORS[Math.floor(Math.random() * COLORS.length)]; // Escolhe aleat√≥ria
         console.log(`Escolha de cor (Bot - s√≥ coringas): Aleat√≥ria -> ${bestColor}`);
    } else if (tiedColors.length === 1) { // Apenas uma cor com maxCount
        bestColor = tiedColors[0];
        console.log(`Escolha de cor (Bot): Maioria -> ${bestColor} (${maxCount} cartas)`);
    } else { // Empate entre cores
        bestColor = tiedColors[Math.floor(Math.random() * tiedColors.length)]; // Desempata aleatoriamente
         console.log(`Escolha de cor (Bot - empate ${tiedColors}): Aleat√≥ria entre as empatadas -> ${bestColor}`);
    }

    return bestColor;
}

// ===== Fun√ß√µes de Intera√ß√£o e Verifica√ß√£o =====

/** Clique no baralho (deck) ou no bot√£o "Comprar Carta". */
function handleDrawClick() {
    // Valida√ß√µes: s√≥ na vez do humano, se o bot n√£o est√° pensando, e jogo ativo
    if (gameOver || currentPlayerIndex !== 0 || botThinking) {
        console.log("handleDrawClick ignorado:", {gameOver, currentPlayerIndex, botThinking});
        return;
    }

    // Se √© obrigado a jogar ou comprar (+ acumulado)
    if (playerMustPlayOrDraw) {
        // Tentar jogar +2/+4 deve ser feito clicando na carta.
        // Clicar em Comprar aqui SIGNIFICA que o jogador DESISTE de jogar e aceita comprar.
        console.log(`Jogador ${currentPlayerIndex} clicou em comprar, aceitando a compra de ${mustDrawCards} cartas.`);
        setStatusMessage(`Voc√™ escolheu comprar ${mustDrawCards} carta(s) e perdeu a vez.`);

        const cardsToDraw = mustDrawCards; // Guarda quantidade
        mustDrawCards = 0;             // Reseta contador
        playerMustPlayOrDraw = false;  // Reseta flag

        drawCardFromDeck(0, cardsToDraw, true); // Executa a compra e atualiza UI

        if(gameOver) return; // Compra pode ter encerrado o jogo

        // Avan√ßa e PULA a vez do jogador que comprou
         advanceTurn(false, true); // false = n√£o checa UNO de quem comprou; true = pula este jogador

    }
    // Se n√£o h√° compra obrigat√≥ria, √© uma compra normal de turno
    else {
        // Verifica se h√° cartas no deck para comprar
        if (deck.length > 0) {
            console.log(`Jogador ${currentPlayerIndex} comprou 1 carta voluntariamente.`);
            setStatusMessage("Voc√™ comprou 1 carta."); // Mensagem inicial
            const drawnCards = drawCardFromDeck(0, 1, false); // Compra 1, sem update imediato

            if (gameOver) return; // Jogo pode ter acabado (empate)

            // Ap√≥s comprar, o jogador N√ÉO PODE jogar a carta comprada na mesma rodada (regra comum).
             // Portanto, passa a vez.
             setStatusMessage("Voc√™ comprou 1 carta e passou a vez.");
             console.log("Passando a vez ap√≥s compra volunt√°ria.");
              updateUI(); // Atualiza UI ANTES de passar a vez
             advanceTurn(true, false); // Avan√ßa (checa UNO de quem comprou), sem pular

        }
        // Se deck vazio, mas PODE reembaralhar
        else if (discardPile.length > 1) {
            console.log("Jogador clicou para reembaralhar o deck vazio.");
             setStatusMessage("Reembaralhando...");
            if (reshuffleDiscardPile()) { // Tenta reembaralhar
                updateUI(); // Atualiza a UI para mostrar o novo deck
                // O jogador agora precisa clicar NOVAMENTE para comprar a carta
                setStatusMessage("Baralho reembaralhado. Clique novamente para comprar uma carta.");
            } else {
                 // Falha no reembaralhamento (n√£o deveria acontecer se discardPile.length > 1)
                 setStatusMessage("Falha ao reembaralhar o baralho.", true);
                 updateUI(); // Atualiza para mostrar o estado (deck continua vazio)
            }
        }
        // Se deck vazio e N√ÉO pode reembaralhar
        else {
            console.log("Jogador tentou comprar, mas n√£o h√° cartas no deck nem para reembaralhar.");
            setStatusMessage("N√£o h√° cartas para comprar ou reembaralhar!", true);
             updateUI(); // Garante que UI reflita deck vazio/imposs√≠vel
             // Nesse caso, o jogador fica travado? Teoricamente sim. Isso leva ao empate que drawCard j√° trata.
        }
    }
}


/** Clique no bot√£o UNO. */
function handleUnoClick() {
    // S√≥ funciona na vez do humano, sem bot pensando, jogo ativo, e se PODE chamar UNO
    if (gameOver || currentPlayerIndex !== 0 || botThinking || !unoBtn) return;

    if (canCallUno[0] && !unoCalled[0]) {
        // Condi√ß√£o correta para gritar UNO
        console.log("Jogador humano gritou UNO!");
        setStatusMessage("Voc√™ gritou UNO!");
        unoCalled[0] = true; // Marca que gritou
        // Atualiza UI do bot√£o e badge
        unoBtn.disabled = true; // Desabilita ap√≥s gritar
        unoBtn.classList.remove('can-press'); // Remove destaque/anima√ß√£o
         playerZoneElement?.classList.add('has-uno'); // Mostra badge visual

        // Opcional: Cancela timer de penalidade se houver um ativo
        // cancelUnoPenaltyTimer(0);

    } else if (unoCalled[0]) {
        // J√° gritou UNO
         setStatusMessage("Voc√™ j√° gritou UNO nesta rodada!", true);
         console.log("Jogador clicou UNO, mas j√° tinha gritado.");
    } else if (!canCallUno[0]) {
         // N√£o est√° na condi√ß√£o de gritar (tem mais de 1 carta, ou acabou de comprar)
        setStatusMessage("Voc√™ n√£o pode gritar UNO agora.", true);
         console.log("Jogador clicou UNO, mas n√£o estava na condi√ß√£o (M√£o:", players[0].hand.length, "CanCall:", canCallUno[0],")");
    }
}

/**
 * Verifica se um jogador deveria ter gritado UNO e n√£o o fez.
 * Aplica penalidade de +2 cartas se necess√°rio.
 * Chamado ANTES de passar a vez para o pr√≥ximo jogador.
 * @param {number} playerId - ID do jogador a ser verificado.
 */
function checkUnoPenalty(playerId) {
    // N√£o aplica penalidade se o jogo acabou ou jogador inv√°lido
    if (gameOver || !players?.[playerId]) return;

    const player = players[playerId];

    // Condi√ß√£o de Penalidade:
    // 1. O jogador ESTAVA na condi√ß√£o de UNO (tinha 1 carta no final do SEU turno anterior)? -> canCallUno[playerId] √© true
    // 2. Ele N√ÉO gritou UNO? -> unoCalled[playerId] √© false
    // 3. A vez j√° est√° passando para o pr√≥ximo? (Esta fun√ß√£o √© chamada nesse momento)
    // (A condi√ß√£o de ter 1 carta √© verificada implicitamente por canCallUno ter sido setado como true)
    if (canCallUno[playerId] && !unoCalled[playerId]) {
        console.warn(`PENALIDADE! Jogador ${playerId} (${player.name}) esqueceu de gritar UNO!`);
        setStatusMessage(`${player.name} esqueceu de gritar UNO! Compra 2 cartas de penalidade.`, true);
        // Aplica penalidade
        drawCardFromDeck(playerId, 2, true); // Compra 2 e atualiza UI

        // Importante: Resetar as flags de UNO ap√≥s a penalidade
         canCallUno[playerId] = false; // N√£o est√° mais em condi√ß√£o UNO ap√≥s comprar
         unoCalled[playerId] = false; // Reset do grito
         // Atualiza UI relacionada ao UNO para este jogador
         if (playerId === 0 && unoBtn) {
             unoBtn.disabled = true;
             unoBtn.classList.remove('can-press');
              playerZoneElement?.classList.remove('has-uno');
         } else if (playerId === 1) {
             opponentZoneElement?.classList.remove('has-uno');
         }
         console.log(`Jogador ${playerId} tem agora ${player.hand.length} cartas ap√≥s penalidade.`);
         // O jogo pode ter acabado aqui se n√£o havia cartas para comprar.
    }
    // N√£o faz nada se n√£o esqueceu ou n√£o estava em condi√ß√£o de UNO.
}


// ===== Event Listeners =====
// Adiciona listeners aos elementos interativos

// Clique no monte de compra (deck)
if (deckPileElement) {
    deckPileElement.addEventListener('click', handleDrawClick);
} else {
    console.error("Erro Cr√≠tico: Elemento #deck-pile n√£o encontrado no DOM.");
}

// Clique no bot√£o "Comprar Carta" (inferior)
if (drawCardBtn) {
    drawCardBtn.addEventListener('click', handleDrawClick);
} else {
    console.error("Erro Cr√≠tico: Bot√£o #draw-card-btn n√£o encontrado no DOM.");
}

// Clique no bot√£o "UNO!" (inferior)
if (unoBtn) {
    unoBtn.addEventListener('click', handleUnoClick);
} else {
    console.error("Erro Cr√≠tico: Bot√£o #uno-btn n√£o encontrado no DOM.");
}

// Clique nos bot√µes de cor do modal
colorButtons.forEach(button => {
    button.addEventListener('click', () => {
        const selectedColor = button.dataset.color;
        if (selectedColor) {
            selectColor(selectedColor); // Chama a fun√ß√£o que processa a escolha
        } else {
            console.error("Bot√£o de cor clicado n√£o possui data-color definido:", button);
        }
    });
});

// Clique no bot√£o "REINICIAR" (topo) - NOVO
if (restartGameBtnTop) {
    restartGameBtnTop.addEventListener('click', () => {
        console.log("Bot√£o REINICIAR (Topo) clicado.");
        // Pergunta se tem certeza? (Opcional)
        // if (confirm("Tem certeza que deseja reiniciar o jogo?")) {
        //     startGame();
        // }
        startGame(); // Reinicia diretamente
    });
} else {
    console.error("Erro: Bot√£o #restart-game-btn (Topo) n√£o encontrado.");
}
// Bot√£o Regras (Topo): Funciona via onclick="window.location.href='regras.html'" no HTML, n√£o precisa de listener JS aqui.

// Atualiza o ano no rodap√© (se o elemento existir)
if (currentYearElement) {
    currentYearElement.textContent = new Date().getFullYear();
}

// ===== Inicializa√ß√£o =====

// Captura erros globais n√£o tratados para tentar dar um feedback
window.addEventListener('error', (event) => {
    console.error('ERRO GLOBAL N√ÉO TRATADO:', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        error: event.error // Objeto do erro, se dispon√≠vel
    });
     // Evita entrar em loop se o pr√≥prio setStatusMessage/endGame der erro
     if (!gameOver) {
         setStatusMessage("Ocorreu um erro inesperado no jogo! Por favor, reinicie.", true);
         endGame(null, true); // Marca como fim por erro
     }
});
window.addEventListener('unhandledrejection', (event) => {
     console.error('REJEI√á√ÉO DE PROMISE N√ÉO TRATADA:', event.reason);
      if (!gameOver) {
          setStatusMessage("Erro ass√≠ncrono inesperado! Por favor, reinicie.", true);
          endGame(null, true);
      }
});


// Inicia o jogo quando o DOM estiver completamente carregado
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM carregado. Iniciando o jogo...");
    // Pequeno delay para garantir que fontes/estilos b√°sicos carregaram
    // antes de iniciar a l√≥gica principal, melhora percep√ß√£o inicial.
    // setTimeout(startGame, 100);
    // Ou inicia direto:
    startGame();
});